#!/usr/bin/env python
"""
capturesim: an attempt to simulate OBS capture and compositing

Definitions:

Presented Frame:
    A frame as created by the game itself and presented to the OS/driver
    for rendering. The rate of presented frames is, effectively, the
    "tick rate" of the simulation.
Captured Frame:
    A frame that has been successfully captured (copied out) by the OBS
    game capture hook.
Output (Composited) Frame:
    A frame that has been successfully composited (along with the rest
    of the scene) by OBS and will be encoded for streaming or recording

For a frame to be recorded, it must be presented (of course), captured,
and composited. Not every presented frame is captured, and not every
captured frame is composited.
"""
import argparse
import csv
import enum
import io
import os
import statistics
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Generator, List, Optional, Protocol, Tuple, Union

from tdvutil.argparse import CheckFile
from xopen import xopen

TESTFILE = "pmcap-Heaven.exe-uncapped-240117-083918.csv"
OBS_FPS = 60.0
OBS_FRAMETIME_MS = 1000.0 / OBS_FPS

gametime_ms = 0.0
obstime_ms = 0.0
last_capture_ms = 0.0
last_render_ms = 0.0
last_capture_frame = -1
last_render_frame = -1

class Disp(enum.Enum):
    """
    Enumeration representing the final disposition of individual presented frames.
    Attributes:
        UNKNOWN: The frame has not yet been processed by the simulation, or has
        not been processed due to a bug.
        IGNORED: The frame has been presented, but the OBS game hook did not
        capture it.
        CAPTURED: The frame has been captured by the OBS game hook.
        COMPOSITED: The frame has been composited into an OBS output frame
        COMPOSITED_DUP: The frame has been composited into multiple OBS output
        frames (i.e. is a duplicate frame in the output)
    """
    UNKNOWN = enum.auto()
    IGNORED = enum.auto()
    CAPTURED = enum.auto()
    COMPOSITED = enum.auto()
    COMPOSITED_DUP = enum.auto()


@dataclass
class GameFrame:
    """
    Represents a frame in the game being captured, as presented to the driver.
    All timestamps are relative to the start of the capture session.

    Attributes:
        present_frame (int): The number of the frame , sequentially starting from 0.
        present_t_ms (float): The timestamp at which this frame was presented to the driver.
        capture_t_ms (Optional[float]): The timestamp at which this frame was captured by
        the game capture hook (if it has been captured, else None)
        composite_t_ms (Optional[float]): The timestamp at which this frame was composited
        by OBS (if it has been composited, else None)
        composite_frame (Optional[int]): The number of the frame in the output stream that
        includes this frame (if it has been composited/output, else None)
        disposition (Disp): The the disposition of the frame at any given point
        in the simulation.
    """
    present_frame: int
    present_t_ms: float
    capture_t_ms: Optional[float] = None
    composite_t_ms: Optional[float] = None
    composite_frame: Optional[int] = None
    disposition: Disp = Disp.UNKNOWN


class FrameStream(Protocol):
    """
    Represents a stream of presented game frames.
    """

    def getframes(self) -> Generator[GameFrame, None, None]:
        """
        Retrieve a generator that outputs game frame information as they would
        be passed to the present call

        Returns:
            A generator that yields GameFrame objects.
        """
        raise NotImplementedError()

class PresentMonCapture(FrameStream):
    """
    Represents a stream of presented game frames generated by reading a
    PresentMon capture file.

    Args:
        filename (Path): The path to the PresentMon capture file.

    Attributes (private):
        _filename (Path): The path to the capture file.
        _reader (Optional[csv.DictReader]): The CSV reader used to read frames from the capture file.
        _gametime_ms (float): The accumulated game time in milliseconds.
    """

    _filename: Path
    _reader: Optional[csv.DictReader] = None  # type: ignore
    _gametime_ms: float = 0.0  # FIXME: Can we just keep this state in getframes?

    def __init__(self, filename: Path) -> None:
        self._filename = filename

    def getframes(self) -> Generator[GameFrame, None, None]:
        """
        Generator that yields GameFrame objects representing the frames in the capture file.

        Yields:
            GameFrame: A game frame object.

        Raises:
            RuntimeError: If frames are already being read from the capture file.
        """
        if self._reader is not None:
            raise RuntimeError(f"already reading frames from {self._filename}")

        fh = xopen(self._filename, 'r')
        self._reader = csv.DictReader(fh, delimiter=',')

        for rownum, row in enumerate(self._reader):
            self._gametime_ms += float(row['msBetweenPresents'])
            yield GameFrame(
                present_frame=rownum,
                present_t_ms=self._gametime_ms,
                disposition=Disp.UNKNOWN,
            )

class GameCapture(Protocol):
    """Interface for simulated capturing of game frames."""

    def capture(self, frame: GameFrame) -> bool:
        """Capture a game frame.

        Args:
            frame (GameFrame): Evaluate and perhaps capture a game frame

        Returns:
            bool: True if the frame was captured, False if the frame was ignored
        """
        raise NotImplementedError()

# FIXME: Right now this just modifies frames in-place where needed, rather
# than returning an updated one. This may or may not be the right interface
class StockGameCapture(GameCapture):
    """
    Represents a stock OBS game capture hook

    Attributes (Private):
        last_capture_frame (int): The frame number of the last capture.
        last_capture_ms (float): The timestamp of the last captured frame.
        game_time_ms (float): The current game timestamp (last frame seen).
        capture_interval_ms (float): The interval between captures in milliseconds.

    Methods:
        __init__(interval: float): Initializes a StockGameCapture instance with the specified capture interval.
        capture(frame: GameFrame) -> bool: Captures a game frame and returns True if successful, False otherwise.
    """

    _last_capture_frame: int = -1
    _last_capture_ms: float = 0.0  # last frame captured
    _game_time_ms: float = 0.0  # current game timestamp (last frame seen)
    _capture_interval_ms: float

    def __init__(self, interval: float) -> None:
        """
        Initializes a StockGameCapture instance with the specified capture interval.

        Args:
            interval (float): The minimum interval between captures in milliseconds.
        """
        self._capture_interval_ms = interval

    def capture(self, frame: GameFrame) -> bool:
        """
        Evaluates a game frame and captures it if more than capture_interval_ms
        time has passed since a previous frame has been captured.

        Args:
            frame (GameFrame): The game frame to potentially capture.

        Returns:
            bool: True if the frame was captured, false otherwise.
        """
        elapsed = frame.present_t_ms - self._last_capture_ms

        # Time to capture?
        if elapsed < self._capture_interval_ms:
            frame.disposition = Disp.IGNORED
            return False

        # Time to capture!
        self._last_capture_frame = frame.present_frame
        frame.disposition = Disp.CAPTURED
        frame.capture_t_ms = frame.present_t_ms

        # set the last capture time so we know when to capture next
        #
        # if the time elapsed has been really long, go from now.
        if elapsed > self._capture_interval_ms * 2:
            self._last_capture_ms = frame.present_t_ms
            return True

        # else we're on a normal cadence, backdate the last capture
        # time to make it an even multiple of half the OBS render
        # interval
        self._last_capture_ms += self._capture_interval_ms
        return True


class Compositor(Protocol):
    """
    Interface for a compositor that combines captured game frames into
    a final output frame
    """

    # FIXME: should this be a property?
    def composited_framelist(self) -> List[GameFrame]:
        """Get the list of game frames that have been composited so far.

        Returns:
            A list of `GameFrame` objects representing the composited frames.
        """
        raise NotImplementedError()

    # FIXME: Should this be a property?
    def next_composite_time(self) -> float:
        """Get the time at which the next composite should occur.

        Returns:
            A float representing the time at which the next composite should occur.
        """
        raise NotImplementedError()

    def composite(self, frame: GameFrame) -> bool:
        """Composite the given game frame into the final composite.

        Args:
            frame: A `GameFrame` object representing the frame to be composited.

        Returns:
            A boolean indicating whether the composite was successful.
        """
        raise NotImplementedError()


class StockOBSCompositor(Compositor):
    """
    A class representing the stock OBS compositor.

    Attributes:
        _composite_interval_ms (float): The interval in milliseconds between composite frames.
        _last_composite_framenum (int): The frame number of the last composited frame.
        _last_composite_t_ms (float): The timestamp of the last composited frame in milliseconds.
        _last_capture_frame (Optional[GameFrame]): The last captured frame.
        _composited_framelist (List[GameFrame]): The list of composited frames.

    Methods:
        __init__(self, fps: float) -> None: Initializes the StockOBSCompositor object.
        composited_framelist(self) -> List[GameFrame]: Returns the list of composited frames.
        next_composite_time(self) -> float: Returns the timestamp of the *next* composited frame.
        composite(self, frame: GameFrame) -> bool: Composites the given frame.

    """

    _composite_interval_ms: float
    _last_composite_framenum: int = -1
    _last_composite_t_ms: float = 0.0
    _last_capture_frame: Optional[GameFrame] = None
    _composited_framelist: List[GameFrame] = []

    def __init__(self, fps: float) -> None:
        """
        Initializes the StockOBSCompositor object.

        Args:
            fps (float): The frames per second of the compositor.

        """
        self._composite_interval_ms = 1000.0 / fps

    def composited_framelist(self) -> List[GameFrame]:
        """
        Returns the list of composited frames.

        Returns:
            List[GameFrame]: The list of composited frames.

        """
        return self._composited_framelist

    def next_composite_time(self) -> float:
        """
        Returns the timestamp of the *next* composited frame.

        Returns:
            float: The timestamp of the next composited frame.

        """
        return self._last_composite_t_ms + self._composite_interval_ms

    def composite(self, frame: GameFrame) -> bool:
        """
        Composites the given frame.

        Args:
            frame (GameFrame): The frame to be composited.

        Returns:
            bool: True if the frame was able to be composited, False otherwise

        """
        if frame.disposition not in [Disp.CAPTURED, Disp.COMPOSITED, Disp.COMPOSITED_DUP]:
            print(
                f"WARNING: composite() called on non-captured frame: {frame.present_frame} @ {frame.present_t_ms} ({frame.disposition})", file=sys.stderr)
            return False

        # We depend on the caller to make sure it's actually *time* to composite.
        # This may or may not be a good idea.
        #
        # Take the provided frame and copy the bits to use as the entry in our
        # composited frame list.
        fakeframe = GameFrame(**frame.__dict__)
        fakeframe.composite_frame = self._last_composite_framenum + 1
        fakeframe.composite_t_ms = self.next_composite_time()
        fakeframe.disposition = Disp.COMPOSITED

        # mark the original frame as composited
        frame.composite_frame = self._last_composite_framenum + 1
        frame.composite_t_ms = self.next_composite_time()

        if self._last_capture_frame is not None and frame.present_frame == self._last_capture_frame.present_frame:
            # duplicate frame, mark it in both the frame passed in, and the
            # frame stored in the composited frame list
            frame.disposition = Disp.COMPOSITED_DUP
            fakeframe.disposition = Disp.COMPOSITED_DUP
        else:
            # new frame, not a dup
            frame.disposition = Disp.COMPOSITED

        self._composited_framelist.append(fakeframe)
        self._last_capture_frame = frame

        # move ourself one composite frame forward
        self._last_composite_framenum += 1
        self._last_composite_t_ms = self.next_composite_time()

        return True

#
# main code
#
def parse_args(args: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Simulate OBS capture & compositing")

    parser.add_argument(
        "--presentmon-file", "--pmf",
        type=Path,
        default=None,
        action=CheckFile(must_exist=True),
        help="use specified PresentMon capture file as pframe source",
    )

    parser.add_argument(
        "--capture-ratio", "--cr",
        type=float,
        default=2,
        help="capture no more than [this ratio] * [OBS FPS] times per second, loosely speaking (set to 0 for no limit)",
    )

    parser.add_argument(
        "--stats-only", "--silent", "-s",
        default=False,
        action="store_true",
        help="print only the statistics, not the presented or captured frame info",
    )

    return parser.parse_args(args)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    if args.presentmon_file is None:
        print("ERROR: no PresentMon file specified", file=sys.stderr)
        return 1

    presented_framelist: List[GameFrame] = []
    captured_framelist: List[GameFrame] = []
    last_captured: Optional[GameFrame] = None

    obs = StockOBSCompositor(OBS_FPS)
    if args.capture_ratio == 0:
        gc = StockGameCapture(0)
    else:
        gc = StockGameCapture(obs._composite_interval_ms / args.capture_ratio)

    print(f"Data from: '{args.presentmon_file}'\nComposite rate {OBS_FPS}fps\n")

    framestream = PresentMonCapture(filename=args.presentmon_file)
    for frame in framestream.getframes():
        # is this frame newer than our next expected compositor time? If so,
        # call the compositor on the frame most recently captured. This
        # simulates having the compositor run on a timer without having to
        # call it for every single game frame just to have it reject most of
        # them
        if last_captured is not None:
            while frame.present_t_ms > obs.next_composite_time():
                obs.composite(last_captured)

        captured = gc.capture(frame)
        if captured:
            last_captured = frame
            captured_framelist.append(frame)

        presented_framelist.append(frame)

    # Don't print frame details in stats-only/silent mode
    def frame_detail_print(outstr: str) -> None:
        if not args.stats_only:
            print(outstr)


    # we're done, print some stuff
    if not args.stats_only:
        print("===== PRESENTED FRAMES =====")
        for frame in presented_framelist:
            if frame.disposition == Disp.COMPOSITED:
                dispstr = f"CAPTURED + COMPOSITED @ otime {frame.composite_t_ms:0.3f}ms"
                # composited_framelist.append(frame)
            elif frame.disposition == Disp.COMPOSITED_DUP:
                dispstr = f"CAPTURED + COMPOSITED (DUPS) @ otime {frame.composite_t_ms:0.3f}ms"
            else:
                dispstr = frame.disposition.name
            print(f"pframe {frame.present_frame} @ {frame.present_t_ms:0.3f}ms, {dispstr}")

    frame_detail_print("\n\n===== OUTPUT/COMPOSITED FRAMES =====")
    prev_present_frame = 0
    prev_present_time = 0.0
    gaplist_frames: List[int] = []
    gaplist_times: List[float] = []

    for frame in obs._composited_framelist:
        frame_gap = frame.present_frame - prev_present_frame
        prev_present_frame = frame.present_frame
        time_gap = frame.present_t_ms - prev_present_time
        prev_present_time = frame.present_t_ms

        gaplist_frames.append(frame_gap)
        gaplist_times.append(time_gap)

        dupstr = " DUP" if frame.disposition == Disp.COMPOSITED_DUP else ""

        frame_detail_print(
            f"oframe {frame.composite_frame} @ {frame.composite_t_ms:0.3f}ms, pframe {frame.present_frame} @ {frame.present_t_ms:0.3f}ms, gap {frame_gap} frames, {time_gap:0.3f}ms{dupstr}")

    print("\n\n===== STATS =====")
    print(f"Presented frames: {len(presented_framelist)}")
    print(
        f"Captured frames: {len(captured_framelist)} ({len(captured_framelist) - len(obs._composited_framelist)} unused)")
    print(f"Composited/output frames: {len(obs._composited_framelist)}")

    gn_avg = statistics.median(gaplist_frames)
    gn_min = min(gaplist_frames)
    gn_max = max(gaplist_frames)
    gn_stddev = statistics.stdev(gaplist_frames)
    print(
        f"\nFrame number gaps: {gn_avg:0.2f} avg, {gn_min} min, {gn_max} max, {gn_stddev:0.2f} stddev")

    gt_avg = statistics.median(gaplist_times)
    gt_min = min(gaplist_times)
    gt_max = max(gaplist_times)
    gt_stddev = statistics.stdev(gaplist_times)
    print(
        f"Frame time gaps: {gt_avg:0.3f} avg, {gt_min:0.3f} min, {gt_max:0.3f} max, {gt_stddev:0.3f} stddev")

    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

sys.exit()


# static inline bool frame_ready(uint64_t interval)
# {
#     static uint64_t last_time = 0;
#     uint64_t elapsed;
#     uint64_t t;

#     if (!interval) {
#         return true;
#     }

#     t = os_gettime_ns();
#     elapsed = t - last_time;

#     if (elapsed < interval) {
#         return false;
#     }

#     last_time = (elapsed > interval * 2) ? t : last_time + interval;
#     return true;
# }
